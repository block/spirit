package lint

import (
	"fmt"
	"strings"

	"github.com/block/spirit/pkg/statement"
	"github.com/pingcap/tidb/pkg/parser/ast"
)

func init() {
	Register(&ReservedWordsLinter{})
}

// mysqlReservedWords contains the list of reserved words from MySQL 9.5.0.
// This list was generated by testing each keyword against a running MySQL server.
// Reserved words cannot be used as identifiers without backtick quoting.
// Total: 259 reserved words
var mysqlReservedWords = map[string]bool{
	"ACCESSIBLE": true, "ADD": true, "ALL": true, "ALTER": true, "ANALYZE": true,
	"AND": true, "AS": true, "ASC": true, "ASENSITIVE": true, "BEFORE": true,
	"BETWEEN": true, "BIGINT": true, "BINARY": true, "BLOB": true, "BOTH": true,
	"BY": true, "CALL": true, "CASCADE": true, "CASE": true, "CHANGE": true,
	"CHAR": true, "CHARACTER": true, "CHECK": true, "COLLATE": true, "COLUMN": true,
	"CONDITION": true, "CONSTRAINT": true, "CONTINUE": true, "CONVERT": true,
	"CREATE": true, "CROSS": true, "CUBE": true, "CUME_DIST": true,
	"CURRENT_DATE": true, "CURRENT_TIME": true, "CURRENT_TIMESTAMP": true,
	"CURRENT_USER": true, "CURSOR": true, "DATABASE": true, "DATABASES": true,
	"DAY_HOUR": true, "DAY_MICROSECOND": true, "DAY_MINUTE": true,
	"DAY_SECOND": true, "DEC": true, "DECIMAL": true, "DECLARE": true,
	"DEFAULT": true, "DELAYED": true, "DELETE": true, "DENSE_RANK": true,
	"DESC": true, "DESCRIBE": true, "DETERMINISTIC": true, "DISTINCT": true,
	"DISTINCTROW": true, "DIV": true, "DOUBLE": true, "DROP": true, "DUAL": true,
	"EACH": true, "ELSE": true, "ELSEIF": true, "EMPTY": true, "ENCLOSED": true,
	"ESCAPED": true, "EXCEPT": true, "EXISTS": true, "EXIT": true, "EXPLAIN": true,
	"FALSE": true, "FETCH": true, "FIRST_VALUE": true, "FLOAT": true,
	"FLOAT4": true, "FLOAT8": true, "FOR": true, "FORCE": true, "FOREIGN": true,
	"FROM": true, "FULLTEXT": true, "FUNCTION": true, "GENERATED": true,
	"GET": true, "GRANT": true, "GROUP": true, "GROUPING": true, "GROUPS": true,
	"HAVING": true, "HIGH_PRIORITY": true, "HOUR_MICROSECOND": true,
	"HOUR_MINUTE": true, "HOUR_SECOND": true, "IF": true, "IGNORE": true,
	"IN": true, "INDEX": true, "INFILE": true, "INNER": true, "INOUT": true,
	"INSENSITIVE": true, "INSERT": true, "INT": true, "INT1": true, "INT2": true,
	"INT3": true, "INT4": true, "INT8": true, "INTEGER": true, "INTERVAL": true,
	"INTO": true, "IO_AFTER_GTIDS": true, "IO_BEFORE_GTIDS": true, "IS": true,
	"ITERATE": true, "JOIN": true, "JSON_TABLE": true, "KEY": true, "KEYS": true,
	"KILL": true, "LAG": true, "LAST_VALUE": true, "LATERAL": true, "LEAD": true,
	"LEADING": true, "LEAVE": true, "LEFT": true, "LIKE": true, "LIMIT": true,
	"LINEAR": true, "LINES": true, "LOAD": true, "LOCALTIME": true,
	"LOCALTIMESTAMP": true, "LOCK": true, "LONG": true, "LONGBLOB": true,
	"LONGTEXT": true, "LOOP": true, "LOW_PRIORITY": true, "MASTER_BIND": true,
	"MASTER_SSL_VERIFY_SERVER_CERT": true, "MATCH": true, "MAXVALUE": true,
	"MEDIUMBLOB": true, "MEDIUMINT": true, "MEDIUMTEXT": true, "MIDDLEINT": true,
	"MINUTE_MICROSECOND": true, "MINUTE_SECOND": true, "MOD": true,
	"MODIFIES": true, "NATURAL": true, "NOT": true, "NO_WRITE_TO_BINLOG": true,
	"NTH_VALUE": true, "NTILE": true, "NULL": true, "NUMERIC": true, "OF": true,
	"ON": true, "OPTIMIZE": true, "OPTIMIZER_COSTS": true, "OPTION": true,
	"OPTIONALLY": true, "OR": true, "ORDER": true, "OUT": true, "OUTER": true,
	"OUTFILE": true, "OVER": true, "PARTITION": true, "PERCENT_RANK": true,
	"PRECISION": true, "PRIMARY": true, "PROCEDURE": true, "PURGE": true,
	"RANGE": true, "RANK": true, "READ": true, "READS": true, "READ_WRITE": true,
	"REAL": true, "RECURSIVE": true, "REFERENCES": true, "REGEXP": true,
	"RELEASE": true, "RENAME": true, "REPEAT": true, "REPLACE": true,
	"REQUIRE": true, "RESIGNAL": true, "RESTRICT": true, "RETURN": true,
	"REVOKE": true, "RIGHT": true, "RLIKE": true, "ROW": true, "ROWS": true,
	"ROW_NUMBER": true, "SCHEMA": true, "SCHEMAS": true, "SECOND_MICROSECOND": true,
	"SELECT": true, "SENSITIVE": true, "SEPARATOR": true, "SET": true, "SHOW": true,
	"SIGNAL": true, "SMALLINT": true, "SPATIAL": true, "SPECIFIC": true,
	"SQL": true, "SQLEXCEPTION": true, "SQLSTATE": true, "SQLWARNING": true,
	"SQL_BIG_RESULT": true, "SQL_CALC_FOUND_ROWS": true, "SQL_SMALL_RESULT": true,
	"SSL": true, "STARTING": true, "STORED": true, "STRAIGHT_JOIN": true,
	"SYSTEM": true, "TABLE": true, "TERMINATED": true, "THEN": true,
	"TINYBLOB": true, "TINYINT": true, "TINYTEXT": true, "TO": true,
	"TRAILING": true, "TRIGGER": true, "TRUE": true, "UNDO": true, "UNION": true,
	"UNIQUE": true, "UNLOCK": true, "UNSIGNED": true, "UPDATE": true, "USAGE": true,
	"USE": true, "USING": true, "UTC_DATE": true, "UTC_TIME": true,
	"UTC_TIMESTAMP": true, "VALUES": true, "VARBINARY": true, "VARCHAR": true,
	"VARCHARACTER": true, "VARYING": true, "VIRTUAL": true, "WHEN": true,
	"WHERE": true, "WHILE": true, "WINDOW": true, "WITH": true, "WRITE": true,
	"XOR": true, "YEAR_MONTH": true, "ZEROFILL": true,
}

// ReservedWordsLinter checks for usage of MySQL reserved words in table and column names.
// Using reserved words as identifiers can cause syntax errors and requires quoting.
type ReservedWordsLinter struct{}

func (l *ReservedWordsLinter) Name() string {
	return "reserved_words"
}

func (l *ReservedWordsLinter) Description() string {
	return "Checks for usage of MySQL reserved words in table and column names"
}

func (l *ReservedWordsLinter) String() string {
	return Stringer(l)
}

// isReservedWord checks if a word is a MySQL reserved keyword
func (l *ReservedWordsLinter) isReservedWord(word string) bool {
	return mysqlReservedWords[strings.ToUpper(word)]
}

func (l *ReservedWordsLinter) Lint(existingTables []*statement.CreateTable, changes []*statement.AbstractStatement) (violations []Violation) {
	// Check CREATE TABLE statements
	for ct := range CreateTableStatements(existingTables, changes) {
		// Check table name
		if l.isReservedWord(ct.TableName) {
			violations = append(violations, Violation{
				Linter:   l,
				Severity: SeverityWarning,
				Location: &Location{
					Table: ct.TableName,
				},
				Message:    fmt.Sprintf("Table name %q is a MySQL reserved word", ct.TableName),
				Suggestion: strPtr(fmt.Sprintf("Use backticks when referencing this table: `%s` or choose a different name", ct.TableName)),
			})
		}

		// Check column names
		for _, column := range ct.Columns {
			if l.isReservedWord(column.Name) {
				violations = append(violations, Violation{
					Linter:   l,
					Severity: SeverityWarning,
					Location: &Location{
						Table:  ct.TableName,
						Column: &column.Name,
					},
					Message:    fmt.Sprintf("Column name %q is a MySQL reserved word", column.Name),
					Suggestion: strPtr(fmt.Sprintf("Use backticks when referencing this column: `%s` or choose a different name", column.Name)),
				})
			}
		}
	}

	// Check ALTER TABLE statements
	for _, change := range changes {
		at, ok := change.AsAlterTable()
		if !ok {
			continue
		}

		tableName := at.Table.Name.String()

		for _, spec := range at.Specs {
			switch spec.Tp {
			case ast.AlterTableAddColumns, ast.AlterTableModifyColumn, ast.AlterTableChangeColumn:
				// Check new column names
				for _, column := range spec.NewColumns {
					columnName := column.Name.Name.O
					if l.isReservedWord(columnName) {
						violations = append(violations, Violation{
							Linter:   l,
							Severity: SeverityWarning,
							Location: &Location{
								Table:  tableName,
								Column: &columnName,
							},
							Message:    fmt.Sprintf("Column name %q is a MySQL reserved word", columnName),
							Suggestion: strPtr(fmt.Sprintf("Use backticks when referencing this column: `%s` or choose a different name", columnName)),
						})
					}
				}
			case ast.AlterTableRenameTable:
				// Check new table name
				if spec.NewTable != nil {
					newTableName := spec.NewTable.Name.O
					if l.isReservedWord(newTableName) {
						violations = append(violations, Violation{
							Linter:   l,
							Severity: SeverityWarning,
							Location: &Location{
								Table: tableName,
							},
							Message:    fmt.Sprintf("New table name %q is a MySQL reserved word", newTableName),
							Suggestion: strPtr(fmt.Sprintf("Use backticks when referencing this table: `%s` or choose a different name", newTableName)),
						})
					}
				}
			}
		}
	}

	return violations
}
